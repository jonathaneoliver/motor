
/******************************************

Included libraries

******************************************/


//#include "Particle.h"
#include <stdarg.h>

#include <application.h>
#include "Adafruit-MotorShield-V2.h"

#include "Encoder.h"

#include "pid.h"

#include "FlySkyIBus.h"

#if 1
#define VERBOSE( XX ) XX
#else
#define VERBOSE( XX )
#endif


/******************************************

Variables

******************************************/


//Define Variables we'll be connecting to
const double kp=0, ki=4.0, kd=0;
double leftSetpoint, leftInput, leftOutput;
double rightSetpoint, rightInput, rightOutput;

//Specify the links and initial tuning parameters
PID leftPID(&leftInput, &leftOutput, &leftSetpoint, kp, ki, kd, PID::DIRECT);
PID rightPID(&rightInput, &rightOutput, &rightSetpoint, kp, ki, kd, PID::DIRECT);

//  balancing PID
const double bkp=2.0, bki=0, bkd=0;
double balanceSetpoint, balanceInput, balanceOutput;
PID balancePID(&balanceInput, &balanceOutput, &balanceSetpoint, bkp, bki, bkd, PID::DIRECT);
//const double balanceOffset=108.5;
const double balanceOffset=-2;

double balanceCorrection( double input )
{
  return input+balanceOffset;
}



// Change these two numbers to the pins connected to your encoder.
// Both pins must have interrupt capability
Encoder rightEnc(D6, D8);
Encoder leftEnc(D5, D4);
//   avoid using pins with LEDs attached

//#define RX_ENABLE D6

#define SPEED_DELTA (100)
#define SPEED_MAX (500)
#define SPEED_MIN (-500)

long oldLeftPosition  = 0;
long oldRightPosition  = 0;
int oldLeftTime  = 0;
int oldRightTime  = 0;
int speed=0;

Adafruit_MotorShield shield = Adafruit_MotorShield();
Adafruit_DCMotor *leftMotor = shield.getMotor(3);
Adafruit_DCMotor *rightMotor = shield.getMotor(4);

#include "Particle.h"
#include "OneWire.h"
#include "Adafruit_BNO055_Photon.h"

#include "I2CSlaveRK.h"

//SYSTEM_MODE(MANUAL);
//SYSTEM_THREAD(ENABLED);

Adafruit_BNO055 bno = Adafruit_BNO055(55);

unsigned long serialTime; //this will help us know when to talk with processing

I2CSlave device(Wire1, 0x10, 10);

//#define MQTT_ENABLE 1

#ifdef MQTT_ENABLE
#include "MQTT.h"

void MQTTcallback(char* topic, byte* payload, unsigned int length);

/**
 * if want to use IP address,
 * byte server[] = { XXX,XXX,XXX,XXX };
 * MQTT client(server, 1883, callback);
 * want to use domain name,
 * exp) iot.eclipse.org is Eclipse Open MQTT Broker: https://iot.eclipse.org/getting-started
 * MQTT client("iot.eclipse.org", 1883, callback);
 **/
byte MQTTserver[] = { 192,168,1,135 };//the IP of broker

MQTT MQTTclient(MQTTserver, 1883, MQTTcallback);

// receive message
void MQTTcallback(char* topic, byte* payload, unsigned int length) {
    char p[length + 1];
    memcpy(p, payload, length);
    p[length] = 0;
    Serial.printlnf("[%s]%.*s",__FUNCTION__,length, payload);

    if (!strcmp(p, "RED"))
        RGB.color(255, 0, 0);
    else if (!strcmp(p, "GREEN"))
        RGB.color(0, 255, 0);
    else if (!strcmp(p, "BLUE"))
        RGB.color(0, 0, 255);
    else
        RGB.color(255, 255, 255);
    delay(100);
}
#endif

/******************************************
void setup()

Runs once upon startup
******************************************/
typedef enum {
  AWAKE,
  ASLEEP
} sleepState_t;

static sleepState_t sleepState=AWAKE;
static int sleepStateTime=0;

#define SLEEPSTATE_PIN A0

const char * SleepStateStr( sleepState_t sleepState )
{
  switch (sleepState) 
  {
    case AWAKE:
      return "AWAKE";
      break;
    case ASLEEP:
      return "ASLEEP";
      break;
    default:
      return "UNKNOWN";
      break;
  }
}




void SleepStateToggle()
{
  // debounce
  if ( millis()-sleepStateTime < 1000 )
  {
    // ignore this
    VERBOSE(  Serial.printlnf( "[%s] %d -> debounce ", __FUNCTION__, millis()) ) ;
    return;
  }

  sleepStateTime=millis();
  

  if ( sleepState==AWAKE )
  {

    VERBOSE( Serial.printlnf( "[%s] %d enter sleep mode for 60 seconds or A0 falling", __FUNCTION__, millis() ) );

    delay(100);
    sleepState=ASLEEP;
    System.sleep(SLEEPSTATE_PIN, FALLING, 60 );
  } 
  else
  {
    /* this is the default when woken from System.sleep() by timer or interrupt from pin */
    sleepState=AWAKE;
  }

  VERBOSE(  Serial.printlnf( "[%s] %d ->%s ", __FUNCTION__, millis(), SleepStateStr(sleepState)) ) ;
}

void SleepStateCheck(void)
{
  if ( digitalRead(SLEEPSTATE_PIN)==LOW )
  {
    VERBOSE(  Serial.printlnf( "[%s] %d sleepState=%s (%d) ", __FUNCTION__, millis(), SleepStateStr(sleepState), digitalRead(SLEEPSTATE_PIN) ) );
    SleepStateToggle();  
  }
}

void SleepStateInit()
{
  VERBOSE( Serial.printlnf( "[%s]", __FUNCTION__ ) );
  pinMode(SLEEPSTATE_PIN, INPUT_PULLUP);    // sets pin as input - high by default
}



void setup() {
  Serial.begin(115200);

  Serial.printlnf("setup()\n");
  


  //Serial.printlnf("[%s]wating for wifi",__FUNCTION__);    
  //waitUntil(WiFi.ready);
  //Serial.printlnf("[%s]wating for wifi ready",__FUNCTION__);    

  if(!bno.begin())
  {
    /* There was a problem detecting the BNO055 ... check your connections */
    Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
    while(1) ;
  }
  //bno.setExtCrystalUse(true);

  delay(100);
  Serial.printlnf("[%s]bno ready",__FUNCTION__);    

  RGB.control(true);
  Serial.printlnf("[%s]rgb ready",__FUNCTION__);    

#ifdef MQTT_ENABLE
  // connect to the server
  MQTTclient.connect(System.deviceID());
  Serial.printlnf("[%s]mqtt ready",__FUNCTION__);    

  // publish/subscribe
  if (MQTTclient.isConnected()) {
    MQTTclient.subscribe("color");//color is the topic that photon is subscribed
    MQTTclient.publish("fun", "hello");//publishing a data "hello" to the topic "fun"
    Serial.printlnf("[%s] publish hello",__FUNCTION__);
  }
  else
  {
    Serial.printlnf("[%s] MQTT FAILED to connect",__FUNCTION__);    
  }
#endif

	device.begin();
  Serial.printlnf("[%s]i2c slave ready",__FUNCTION__);    

  SleepStateInit();
  Serial.printlnf("[%s]low power ready",__FUNCTION__);    
#if 0

  //pinMode(RX_ENABLE, OUTPUT);
  //digitalWrite(RX_ENABLE, HIGH);
  /* Initialize the sensor */
  if(!bno.begin())
  {
    /* There was a problem detecting the BNO055 ... check your connections */
    Serial.print("Ooops, no BNO055 detected ... Check your wiring or I2C ADDR!");
    while(1) ;
  }

  delay(1000);
#endif



  IBus.begin(Serial1);
  Serial.printlnf("[%s]ibus ready",__FUNCTION__);    

  Serial.printlnf(__FUNCTION__);
  
  shield.begin();

  balanceSetpoint=0;
  balancePID.SetMode(PID::AUTOMATIC);
  balancePID.SetOutputLimits(-255, 255);
  balancePID.SetSampleTime(100);

  leftSetpoint=0;
  rightSetpoint=0;

  speed=setPwm( leftMotor, 0);
  speed=setPwm( rightMotor, 0);

  leftPID.SetMode(PID::AUTOMATIC);
  leftPID.SetOutputLimits(-255, 255);
  leftPID.SetSampleTime(250);

  rightPID.SetMode(PID::AUTOMATIC);
  rightPID.SetOutputLimits(-255, 255);
  rightPID.SetSampleTime(250);
  Serial.printlnf("[%s]pids ready",__FUNCTION__);    
  
  Serial.printlnf("setup( complete )\n");

}

/******************************************
void loop()

Runs forever
******************************************/
int setPwm( Adafruit_DCMotor *motor, int speed )
{  
  if( speed==0 ) {
    motor->setSpeed(abs(speed));
    motor->run(RELEASE);
  }
  else if( speed>0 ) {
    motor->run(FORWARD);
    motor->setSpeed(abs(speed));
  }
  else
  {
    motor->run(BACKWARD);
    motor->setSpeed(abs(speed));      
  }
  return speed;
}

int setTargetSpeed( int speed )
{  
  leftSetpoint=rightSetpoint=speed;
  return speed;
}

void telemetrySend( const char *name, const char *format, ...)
{
#ifdef MQTT_ENABLE
      if (MQTTclient.isConnected())
      {
        char buffer[256];
        va_list args;
        va_start (args, format);
        vsnprintf (buffer, sizeof(buffer), format, args);
        va_end (args);
        MQTTclient.publish( name, buffer );
      }
      else 
      {
        Serial.printlnf("[%s]client failed to connect",__FUNCTION__);
        // connect to the server
        MQTTclient.connect(System.deviceID());
        Serial.printlnf("[%s]mqtt ready",__FUNCTION__);    

        // publish/subscribe
        if (MQTTclient.isConnected()) {
          MQTTclient.subscribe("color");//color is the topic that photon is subscribed
          MQTTclient.publish("fun", "hello");//publishing a data "hello" to the topic "fun"
          Serial.printlnf("[%s] publish hello",__FUNCTION__);
        }
        else
        {
          Serial.printlnf("[%s] MQTT FAILED to connect",__FUNCTION__);    
        }
      }
#endif      
}


void loop() 
{
  static bool TxOn=false;

  SleepStateCheck();

	uint16_t regAddr;
	while(device.getRegisterSet(regAddr)) {
		// regAddr was updated from the I2C master
		Serial.printlnf("master updated %u to %u", regAddr, device.getRegister(regAddr));
	}

#ifdef MQTT_ENABLE
  if (MQTTclient.isConnected())
  {
    MQTTclient.loop();
  }
  else
  {
    Serial.printlnf("[%s]client failed to connect",__FUNCTION__);
  #ifdef MQTT_ENABLE
    // connect to the server
    MQTTclient.connect(System.deviceID());
    Serial.printlnf("[%s]mqtt ready",__FUNCTION__);    

    // publish/subscribe
    if (MQTTclient.isConnected()) {
      MQTTclient.subscribe("color");//color is the topic that photon is subscribed
      MQTTclient.publish("fun", "hello");//publishing a data "hello" to the topic "fun"
      Serial.printlnf("[%s] publish hello",__FUNCTION__);
    }
    else
    {
      Serial.printlnf("[%s] MQTT FAILED to connect",__FUNCTION__);    
    }
#endif
  
  }
#endif


  /* Get a new sensor event */
  sensors_event_t event;
  bno.getEvent(&event);
#if 1
  static double prevZ=0.0;

  if ( prevZ != event.orientation.z )
  {
    /* Display the floating point data */
#if 0
   Serial.printlnf("(%d) X: %f\tY: %f\tZ: %f", millis(), event.orientation.x, event.orientation.y, event.orientation.z );

    uint8_t system, gyro, accel, mag = 0;
    bno.getCalibration(&system, &gyro, &accel, &mag);
    Serial.printlnf("CALIBRATION: Sys=%d\tGyro=%d\tAccel=%d\tMag=%d", system, gyro, accel, mag );
    imu::Vector<3> euler = bno.getVector(Adafruit_BNO055::VECTOR_EULER);
    Serial.printlnf("X: %f\tY: %f\tZ: %f", euler.x(), euler.y(), euler.z() );
#else
    VERBOSE( Serial.printlnf("(%d) Z: %f", millis(), event.orientation.z ) );
    prevZ = event.orientation.z;

    VERBOSE( Serial.printlnf("(%d) set Z for i2c : %f", millis(), event.orientation.z ) );
		device.setRegister(0, int(event.orientation.z*100));

    telemetrySend( "imu", "{ '_time': '%lu', 'type': 'imu', 'X': '%f', 'Y':'%f', Z' : '%f' }",millis(), event.orientation.x, event.orientation.y, event.orientation.z );
    balanceInput=balanceCorrection( event.orientation.z );


#endif
  }


#endif

  //if ( digitalRead(RX_ENABLE) ) 
  { 
    IBus.loop();

    // TX ON ( top left switch )
    telemetrySend( "iBus", "{ \"_time\": \"%lu\", \"type\":\"iBus\", \"name\":\"iBus\", \"0\" : \"%x\", \"1\"  : \"%x\", \"2\" : \"%x\", \"3\":\"%x\", \"4\":\"%x\", \"5\":\"%x\", \"6\":\"%x\", \"7\":\"%x\", \"8\":\"%x\", \"9\":\"%x\" }", millis(), IBus.readChannel(0),IBus.readChannel(1),IBus.readChannel(2),IBus.readChannel(3),IBus.readChannel(4),IBus.readChannel(5),IBus.readChannel(6),IBus.readChannel(7),IBus.readChannel(8),IBus.readChannel(9) );

    if ( IBus.readChannel(5)==0x7d0 )
    {
      static double prevLeftSetpoint=-1;
      static double prevRightSetpoint=-1;
      
      TxOn=true;

      // right
      rightSetpoint=max( min( IBus.readChannel(1)-0x5dc, SPEED_MAX ), SPEED_MIN );
      if ( rightSetpoint != prevRightSetpoint ) {
        Serial.printlnf("rightSpeed from RX = %d", rightSetpoint );
        prevRightSetpoint=rightSetpoint;
      }

      // left
      leftSetpoint=double(max( min( IBus.readChannel(2)-0x5dc, SPEED_MAX ), SPEED_MIN ));
      if ( leftSetpoint != prevLeftSetpoint ){
        //Serial.printlnf("leftSpeed from RX = %f", leftSetpoint );
        prevLeftSetpoint=leftSetpoint;
      }
    }
    else if ( TxOn && IBus.readChannel(5)!=0x7d0 )
    {
      TxOn=false;
      speed=setTargetSpeed(0);    
    }

    if ( IBus.readChannel(8)==0x7d0 )
    {
      // OK use RC input for balance target angle
      balanceInput=(90.0*(IBus.readChannel(1)-0x5dc))/500.0;
    }
  }

  //Serial.printlnf( "[%s]%f", __FUNCTION__, leftInput );
  if ( balancePID.Compute() )
  {
    leftSetpoint=balanceOutput;
    rightSetpoint=balanceOutput;

    Serial.printlnf( "balancePid { \"_time\": \"%lu\", \"Input\" : \"%f\", \"Setpoint\"  : \"%f\", \"Output\" : \"%f\" }", millis(), balanceInput, balanceSetpoint, balanceOutput  ) ;

    telemetrySend( "balancePid", "{ \"_time\": \"%lu\", \"type\":\"pid\", \"name\":\"balancePid\", \"Input\" : \"%f\", \"Setpoint\"  : \"%f\", \"Output\" : \"%f\", \"Kp\":\"%f\", \"Ki\":\"%f\", \"Kd\":\"%f\", \"mode\":\"%s\"  }", millis(), balanceInput, balanceSetpoint, balanceOutput, balancePID.GetKp(), balancePID.GetKi(), balancePID.GetKd(), (balancePID.GetMode()==PID::AUTOMATIC)?"AUTOMATIC":"MANUAL" ) ;
  }

  if (Serial.available())
  {
    int inByte = Serial.read();
    switch (inByte)
    {
        case ' ':
          // reset PID
          leftPID.SetMode(PID::MANUAL);
          leftOutput=0;
          setPwm( leftMotor, leftOutput);

          rightPID.SetMode(PID::MANUAL);
          rightOutput=0;
          setPwm( rightMotor, rightOutput);

          speed=setTargetSpeed(0);
          leftPID.SetMode(PID::AUTOMATIC);
          rightPID.SetMode(PID::AUTOMATIC);
          break;
        case '1':
          speed=setTargetSpeed(speed-SPEED_DELTA);
          break;
        case'2':
          speed=setTargetSpeed(speed+SPEED_DELTA);
          break;
        case '3':
          speed=setTargetSpeed(-speed);
          break;
        case '9':
          SleepStateToggle();
          break;
        default:
          break;
    }
  }

  long newLeftPosition = leftEnc.read();
  long newRightPosition = rightEnc.read();
  int now=millis();

#if 1
  if ( oldLeftTime==0 )
  {
    // do nothing
    oldLeftTime = now;
    leftInput = 0;
  } 
  else if (now-oldLeftTime>0)
  {  
    //Serial.printlnf( "[%s]%d", __FUNCTION__, now-oldLeftTime );
    leftInput = (((newLeftPosition-oldLeftPosition)*60000)/(18.75*64*(now-oldLeftTime)))/3;
  }
  //Serial.printlnf( "[%s]%f", __FUNCTION__, leftInput );
  if ( leftPID.Compute() )
  {
    setPwm( leftMotor, leftOutput);
    //Serial.printlnf( "[%s]%d left speed=%d, delta=%d (position=%d) RPM=%f", __FUNCTION__, now, speed, newLeftPosition-oldLeftPosition, newLeftPosition, leftInput );
    VERBOSE( Serial.printlnf( "[%s] %d - left pid input=%f, setpoint=%f, output=%f", __FUNCTION__, now, leftInput, leftSetpoint, leftOutput) );

    telemetrySend( "leftPid", "{ \"_time\": \"%lu\", \"type\":\"pid\", \"name\":\"leftPid\", \"Input\" : \"%f\", \"Setpoint\"  : \"%f\", \"Output\" : \"%f\", \"Kp\":\"%f\", \"Ki\":\"%f\", \"Kd\":\"%f\", \"mode\":\"%s\"  }", millis(), leftInput, leftSetpoint, leftOutput, leftPID.GetKp(), leftPID.GetKi(), leftPID.GetKd(), (leftPID.GetMode()==PID::AUTOMATIC)?"AUTOMATIC":"MANUAL" ) ;

    oldLeftPosition = newLeftPosition;
    oldLeftTime = now;
  }
#endif

#if 1
  if ( oldRightTime==0 )
  {
    // do nothing
    oldRightTime = now;
    rightInput = 0;
  } 
  else if (now-oldRightTime>0)
  {  
    rightInput = (((newRightPosition-oldRightPosition)*60000)/(18.75*64*(now-oldRightTime)))/3;
  }

  if ( rightPID.Compute() )
    {
      setPwm( rightMotor, rightOutput);
      //Serial.printlnf( "[%s]%d right speed=%d, delta=%d (position=%d) RPM=%f", __FUNCTION__, time, speed, newRightPosition-oldRightPosition, newRightPosition, rightInput);
      VERBOSE( Serial.printlnf( "[%s] %d - right pid input=%f, setpoint=%f, output=%f", __FUNCTION__, now, rightInput, rightSetpoint, rightOutput) );

      telemetrySend( "rightPid", "{ \"_time\": %lu, \"type\":\"pid\", \"name\":\"rightPid\", \"Input\" : %f, \"Setpoint\"  : %f, \"Output\" : %f, \"Kp\":%f, \"Ki\":%f, \"Kd\":%f, \"mode\":\"%s\"  }"        , millis(), rightInput, rightSetpoint, rightOutput, rightPID.GetKp(), rightPID.GetKi(), rightPID.GetKd(), (rightPID.GetMode()==PID::AUTOMATIC)?"AUTOMATIC":"MANUAL" ) ;

      oldRightPosition = newRightPosition;
      oldRightTime = now;
    }
#endif


}
